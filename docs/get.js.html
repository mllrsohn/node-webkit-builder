<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: get.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: get.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import child_process from "node:child_process";
import fs from "node:fs";
import fsp from "node:fs/promises";
import https from "node:https";
import path from "node:path";
import process from "node:process";

import progress from "cli-progress";
import compressing from "compressing";
import yauzl from "yauzl-promise";

import * as logger from "./log.js";
import * as util from "./util.js";

const { log } = logger;
const { ARCH_KV, PLATFORM_KV, replaceFfmpeg } = util;

/**
 * @typedef {object} GetOptions
 * @property {string | "latest" | "stable" | "lts"} [options.version = "latest"]                  Runtime version
 * @property {"normal" | "sdk"}                     [options.flavor = "normal"]                   Build flavor
 * @property {"linux" | "osx" | "win"}              [options.platform]                            Target platform
 * @property {"ia32" | "x64" | "arm64"}             [options.arch]                                Target architecture
 * @property {string}                               [options.downloadUrl = "https://dl.nwjs.io"]  Download server
 * @property {string}                               [options.cacheDir = "./cache"]                Cache directory
 * @property {string}                               [options.outDir = "./out"]                    Out directory
 * @property {boolean}                              [options.cache = true]                        If false, remove cache and redownload.
 * @property {boolean}                              [options.ffmpeg = false]                      If true, ffmpeg is not downloaded.
 * @property {false | "gyp"}                        [options.nativeAddon = false]                 Rebuild native modules
 */

/**
 * Get binaries.
 *
 * @function
 * @param  {GetOptions}    options  Get mode options
 * @return {Promise&lt;void>}
 *
 * @example
 * // Minimal Usage (uses default values)
 * nwbuild({
 *   mode: "get",
 * });
 *
 * @example
 * // Unofficial macOS builds (upto v0.75.0)
 * nwbuild({
 *   mode: "get",
 *   platform: "osx",
 *   arch: "arm64",
 *   downloadUrl: "https://github.com/corwin-of-amber/nw.js/releases/download",
 *   manifestUrl: "https://raw.githubusercontent.com/nwutils/nw-builder/main/src/util/osx.arm.versions.json",
 * });
 *
 * @example
 * // China mirror
 * nwbuild({
 *  mode: "get",
 *  downloadUrl: "https://npm.taobao.org/mirrors/nwjs",
 * });
 *
 * @example
 * // Singapore mirror
 * nwbuild({
 *  mode: "get",
 *  downloadUrl: "https://cnpmjs.org/mirrors/nwjs/",
 * });
 *
 * @example
 * // FFMPEG (proprietary codecs)
 * // Please read the license's constraints: https://nwjs.readthedocs.io/en/latest/For%20Developers/Enable%20Proprietary%20Codecs/#get-ffmpeg-binaries-from-the-community
 * nwbuild({
 *   mode: "get",
 *   ffmpeg: true,
 * });
 *
 * @example
 * // Get Node headers
 * nwbuild({
 *   mode: "get",
 *   nativeAddon: "gyp",
 * });
 */
export async function get({
  version = "latest",
  flavor = "normal",
  platform = PLATFORM_KV[process.platform],
  arch = ARCH_KV[process.arch],
  downloadUrl = "https://dl.nwjs.io",
  cacheDir = "./cache",
  cache = true,
  ffmpeg = false,
  nativeAddon = false,
}) {
  await getNwjs({
    version,
    flavor,
    platform,
    arch,
    downloadUrl,
    cacheDir,
    cache,
  });
  if (ffmpeg === true) {
    await getFfmpeg({
      version,
      flavor,
      platform,
      arch,
      downloadUrl,
      cacheDir,
      cache,
    });
  }
  if (nativeAddon === "gyp") {
    await getNodeHeaders({
      version: version,
      platform: platform,
      arch: arch,
      cacheDir: cacheDir,
      cache: cache,
    });
  }
}

const getNwjs = async ({
  version = "latest",
  flavor = "normal",
  platform = PLATFORM_KV[process.platform],
  arch = ARCH_KV[process.arch],
  downloadUrl = "https://dl.nwjs.io",
  cacheDir = "./cache",
  cache = true,
}) => {
  const bar = new progress.SingleBar({}, progress.Presets.rect);
  const out = path.resolve(
    cacheDir,
    `nwjs${flavor === "sdk" ? "-sdk" : ""}-v${version}-${platform}-${arch}.${
      platform === "linux" ? "tar.gz" : "zip"
    }`,
  );
  // If options.cache is false, remove cache.
  if (cache === false) {
    log.debug(`Removing existing NW.js binaries.`);
    await fsp.rm(out, {
      recursive: true,
      force: true,
    });
    log.debug(`Existing NW.js binaries removed.`);
  }

  if (fs.existsSync(out) === true) {
    log.debug(`Found existing NW.js binaries.`);
    await fsp.rm(
      path.resolve(
        cacheDir,
        `nwjs${flavor === "sdk" ? "-sdk" : ""}-v${version}-${platform}-${arch}`,
      ),
      { recursive: true, force: true },
    );
    await compressing[platform === "linux" ? "tgz" : "zip"].uncompress(
      out,
      cacheDir,
    );

    return;
  }

  const stream = fs.createWriteStream(out);
  const request = new Promise((res, rej) => {
    let url = "";

    // Set download url and destination.
    if (
      downloadUrl === "https://dl.nwjs.io" ||
      downloadUrl === "https://npm.taobao.org/mirrors/nwjs" ||
      downloadUrl === "https://npmmirror.com/mirrors/nwjs"
    ) {
      url = `${downloadUrl}/v${version}/nwjs${
        flavor === "sdk" ? "-sdk" : ""
      }-v${version}-${platform}-${arch}.${
        platform === "linux" ? "tar.gz" : "zip"
      }`;
    }

    https.get(url, (response) => {
      // For GitHub releases and mirrors, we need to follow the redirect.
      if (
        downloadUrl === "https://npm.taobao.org/mirrors/nwjs" ||
        downloadUrl === "https://npmmirror.com/mirrors/nwjs"
      ) {
        url = response.headers.location;
      }

      https.get(url, (response) => {
        log.debug(`Downloading from ${url}`);
        let chunks = 0;
        bar.start(Number(response.headers["content-length"]), 0);
        response.on("data", (chunk) => {
          chunks += chunk.length;
          bar.increment();
          bar.update(chunks);
        });

        response.on("error", (error) => {
          rej(error);
        });

        response.on("end", () => {
          log.debug(`NW.js download complete.`);
          bar.stop();
          res();
        });

        response.pipe(stream);
      });

      response.on("error", (error) => {
        rej(error);
      });
    });
  });

  return request.then(async () => {
    log.debug("Remove existing NW.js before decompression.");
    await fsp.rm(
      path.resolve(
        cacheDir,
        `nwjs${flavor === "sdk" ? "-sdk" : ""}-v${version}-${platform}-${arch}`,
      ),
      { recursive: true, force: true },
    );
    log.debug("Decompress NW.js binaries.");
    if (platform === "osx" &amp;&amp; process.platform === "darwin") {
      const zip = await yauzl.open(out);
      try {
        for await (const entry of zip) {
          const fullEntryPath = path.resolve(cacheDir, entry.filename);

          if (entry.filename.endsWith("/")) {
            // Create directory
            await fsp.mkdir(fullEntryPath, { recursive: true });
          } else {
            // Create the file's directory first, if it doesn't exist
            const directory = path.dirname(fullEntryPath);
            await fsp.mkdir(directory, { recursive: true });

            const readStream = await entry.openReadStream();
            const writeStream = fs.createWriteStream(fullEntryPath);

            await new Promise((res, rej) => {
              readStream.pipe(writeStream);
              readStream.on("error", rej);
              writeStream.on("error", rej);
              writeStream.on("finish", res);
            });
          }
        }
      } catch (e) {
        log.error(e);
      } finally {
        await zip.close();
      }
    } else {
      await compressing[platform === "linux" ? "tgz" : "zip"].uncompress(
        out,
        cacheDir,
      );
    }
  });
};

const getFfmpeg = async ({
  version = "latest",
  flavor = "normal",
  platform = PLATFORM_KV[process.platform],
  arch = ARCH_KV[process.arch],
  cacheDir = "./cache",
  cache = true,
}) => {
  const nwDir = path.resolve(
    cacheDir,
    `nwjs${flavor === "sdk" ? "-sdk" : ""}-v${version}-${platform}-${arch}`,
  );
  const bar = new progress.SingleBar({}, progress.Presets.rect);

  // If options.ffmpeg is true, then download ffmpeg.
  const downloadUrl =
    "https://github.com/nwjs-ffmpeg-prebuilt/nwjs-ffmpeg-prebuilt/releases/download";
  let url = `${downloadUrl}/${version}/${version}-${platform}-${arch}.zip`;
  const out = path.resolve(
    cacheDir,
    `ffmpeg-v${version}-${platform}-${arch}.zip`,
  );

  // If options.cache is false, remove cache.
  if (cache === false) {
    log.debug(`Removing existing FFmpeg binary.`);
    await fsp.rm(out, {
      recursive: true,
      force: true,
    });
    log.debug(`Existing FFmpeg binary removed.`);
  }

  // Check if cache exists.
  if (fs.existsSync(out) === true) {
    log.debug(`Found existing FFmpeg binary.`);
    await compressing.zip.uncompress(out, nwDir);
    return;
  }

  const stream = fs.createWriteStream(out);
  const request = new Promise((res, rej) => {
    https.get(url, (response) => {
      // For GitHub releases and mirrors, we need to follow the redirect.
      url = response.headers.location;

      https.get(url, (response) => {
        log.debug(`Downloading from ${url}`);
        let chunks = 0;
        bar.start(Number(response.headers["content-length"]), 0);
        response.on("data", (chunk) => {
          chunks += chunk.length;
          bar.increment();
          bar.update(chunks);
        });

        response.on("error", (error) => {
          rej(error);
        });

        response.on("end", () => {
          log.debug(`FFmpeg download complete.`);
          bar.stop();
          res();
        });

        response.pipe(stream);
      });

      response.on("error", (error) => {
        rej(error);
      });
    });
  });

  // Remove compressed file after download and decompress.
  return request.then(async () => {
    await compressing.zip.uncompress(out, nwDir);
    await replaceFfmpeg(platform, nwDir);
  });
};

const getNodeHeaders = async ({
  version = "latest",
  platform = PLATFORM_KV[process.platform],
  arch = ARCH_KV[process.arch],
  cacheDir = "./cache",
  cache = true,
}) => {
  const bar = new progress.SingleBar({}, progress.Presets.rect);
  const out = path.resolve(
    cacheDir,
    `headers-v${version}-${platform}-${arch}.tar.gz`,
  );

  // If options.cache is false, remove cache.
  if (cache === false) {
    log.debug(`Removing existing Node headers.`);
    await fsp.rm(out, {
      recursive: true,
      force: true,
    });
    log.debug(`Existing Node headers removed.`);
  }

  if (fs.existsSync(out) === true) {
    log.debug(`Found existing Node headers cache.`);
    await compressing.tgz.uncompress(out, cacheDir);
    await fsp.rm(
      path.resolve(cacheDir, `node-v${version}-${platform}-${arch}`),
      {
        recursive: true,
        force: true,
      },
    );
    await fsp.rename(
      path.resolve(cacheDir, "node"),
      path.resolve(cacheDir, `node-v${version}-${platform}-${arch}`),
    );

    child_process.exec(
      "patch " +
        path.resolve(
          cacheDir,
          `node-v${version}-${platform}-${arch}`,
          "common.gypi",
        ) +
        " " +
        path.resolve("..", "..", "patches", "node_header.patch"),
      (error) => {
        log.error(error);
      },
    );

    return;
  }

  const stream = fs.createWriteStream(out);
  const request = new Promise((res, rej) => {
    const urlBase = "https://dl.nwjs.io/";
    const url = `${urlBase}/v${version}/nw-headers-v${version}.tar.gz`;
    https.get(url, (response) => {
      log.debug(`Response from ${url}`);
      let chunks = 0;
      bar.start(Number(response.headers["content-length"]), 0);
      response.on("data", (chunk) => {
        chunks += chunk.length;
        bar.increment();
        bar.update(chunks);
      });

      response.on("error", (error) => {
        rej(error);
      });

      response.on("end", () => {
        log.debug(`FFMPEG fully downloaded`);
        bar.stop();
        res();
      });

      response.pipe(stream);
    });
  });

  return request.then(async () => {
    await compressing.tgz.uncompress(out, cacheDir);
    await fsp.rename(
      path.resolve(cacheDir, "node"),
      path.resolve(cacheDir, `node-v${version}-${platform}-${arch}`),
    );
  });
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#get">get</a></li><li><a href="global.html#run">run</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Thu Nov 30 2023 23:21:46 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
